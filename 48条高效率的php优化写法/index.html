<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>48条高效率的PHP优化写法 - 大风</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="大风"><meta name="msapplication-TileImage" content="/images/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="大风"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="来源：歪麦博客 https:&amp;#x2F;&amp;#x2F;www.awaimai.com&amp;#x2F;1050.html 这里列举了一些PHP的高效写法。"><meta property="og:type" content="blog"><meta property="og:title" content="48条高效率的PHP优化写法"><meta property="og:url" content="https://kkai.blog/48%E6%9D%A1%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84PHP%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/"><meta property="og:site_name" content="大风"><meta property="og:description" content="来源：歪麦博客 https:&amp;#x2F;&amp;#x2F;www.awaimai.com&amp;#x2F;1050.html 这里列举了一些PHP的高效写法。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://kkai.blog/img/og_image.png"><meta property="article:published_time" content="2018-05-31T15:02:51.000Z"><meta property="article:modified_time" content="2022-04-27T13:17:08.627Z"><meta property="article:author" content="kkai"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kkai.blog/48%E6%9D%A1%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84PHP%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/"},"headline":"48条高效率的PHP优化写法","image":["https://kkai.blog/img/og_image.png"],"datePublished":"2018-05-31T15:02:51.000Z","dateModified":"2022-04-27T13:17:08.627Z","author":{"@type":"Person","name":"kkai"},"publisher":{"@type":"Organization","name":"大风","logo":{"@type":"ImageObject","url":"https://kkai.blog/images/ban_logo.png"}},"description":"来源：歪麦博客 https:&#x2F;&#x2F;www.awaimai.com&#x2F;1050.html 这里列举了一些PHP的高效写法。"}</script><link rel="canonical" href="https://kkai.blog/48%E6%9D%A1%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84PHP%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95/"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-SFT63EXSKM" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-SFT63EXSKM');</script><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/ban_logo.png" alt="大风" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/sneiiler"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2018-05-31T15:02:51.000Z" title="2018/5/31 23:02:51">2018-05-31</time>发表</span><span class="level-item"><time dateTime="2022-04-27T13:17:08.627Z" title="2022/4/27 21:17:08">2022-04-27</time>更新</span><span class="level-item">31 分钟读完 (大约4645个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">48条高效率的PHP优化写法</h1><div class="content"><p>来源：歪麦博客</p>
<p><a target="_blank" rel="noopener" href="https://www.awaimai.com/1050.html">https://www.awaimai.com/1050.html</a></p>
<p>这里列举了一些PHP的高效写法。</p>
<span id="more"></span>

<p>[toc]</p>
<h1 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1 字符串"></a>1 字符串</h1><h2 id="1-1-少用正则表达式"><a href="#1-1-少用正则表达式" class="headerlink" title="1.1 少用正则表达式"></a>1.1 少用正则表达式</h2><p>能用PHP内部字符串操作函数的情况下，尽量用他们，不要用正则表达式， 因为其效率高于正则。</p>
<p>没得说，正则最耗性能。</p>
<p>str_replace函数要比preg_replace快得多，strtr函数又比str_replace来得快。</p>
<p>有没有你漏掉的好用的函数？</p>
<p>例如：strpbrk()、strncasecmp()、strpos()、strrpos()、stripos()、strripos()。</p>
<h2 id="1-2-字符替换"><a href="#1-2-字符替换" class="headerlink" title="1.2 字符替换"></a>1.2 字符替换</h2><p>如果需要转换的全是单个字符，用字符串作为 strtr() 函数完成替换，而不是数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$addr</span> = <span class="title function_ invoke__">strtr</span>(<span class="variable">$addr</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;efgh&quot;</span>);       <span class="comment">// 建议</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$addr</span> = <span class="title function_ invoke__">strtr</span>(<span class="variable">$addr</span>, <span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span> =&gt; <span class="string">&#x27;e&#x27;</span>, ));  <span class="comment">// 不建议</span></span><br></pre></td></tr></table></figure>

<p>效率提升：10 倍。</p>
<p>str_replace字符替换比正则替换preg_replace快，但strtr比str_replace又快1&#x2F;4。</p>
<p>另外，不要做无谓的替换，即使没有替换，str_replace也会为其参数分配内存。很慢！</p>
<p>用 strpos 先查找（非常快），看是否需要替换，如果需要，再替换。</p>
<p>如果需要替换，效率几乎相等，差别在 0.1% 左右。</p>
<p>如果不需要替换：用 strpos 快 200%。</p>
<h2 id="1-3-压缩大的字符串"><a href="#1-3-压缩大的字符串" class="headerlink" title="1.3 压缩大的字符串"></a>1.3 压缩大的字符串</h2><p>使用 gzcompress() 和 gzuncompress() 对容量大的字符串进行压缩和解压，再存入和取出数据库。</p>
<p>这种内置的函数使用gzip算法，能压缩字符串90%。</p>
<h2 id="1-4-echo-输出"><a href="#1-4-echo-输出" class="headerlink" title="1.4 echo 输出"></a>1.4 echo 输出</h2><p>echo 字符串用逗号代替点连接符更快些。</p>
<p>虽然，echo是一种语言结构，不是真正的函数。</p>
<p>但是，它可以把逗号隔开的多个字符串当作“函数”参数传入，所以速度会更快。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="variable">$str1</span>, <span class="variable">$str2</span>;       <span class="comment">// 速度快</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str1</span> . <span class="variable">$str2</span>;      <span class="comment">// 速度稍慢</span></span><br></pre></td></tr></table></figure>


<h2 id="1-5-尽量用单引号"><a href="#1-5-尽量用单引号" class="headerlink" title="1.5 尽量用单引号"></a>1.5 尽量用单引号</h2><p>PHP 引擎允许使用单引号和双引号来封装字符串变量，但是它们的速度是有很大的差别的！</p>
<p>使用双引号的字符串会告诉 PHP 引擎，首先去读取字符串内容，查找其中的变量，并改为变量对应的值。</p>
<p>一般来说字符串是没有变量的，使用双引号会导致性能不佳。</p>
<p>最好使用字符串连接，而不是双引号字符串。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$output</span> = <span class="string">&quot;This is a plain string&quot;</span>;  <span class="comment">// 不好的实践</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$output</span> = <span class="string">&#x27;This is a plain string&#x27;</span>;  <span class="comment">// 好的实践</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="variable">$type</span> = <span class="string">&quot;mixed&quot;</span>;                     <span class="comment">// 不好的实践</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$output</span> = <span class="string">&quot;This is a <span class="subst">$type</span> string&quot;</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="variable">$type</span> = <span class="string">&#x27;mixed&#x27;</span>;                     <span class="comment">// 好的实践</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$output</span> = <span class="string">&#x27;This is a &#x27;</span> . <span class="variable">$type</span> . <span class="string">&#x27; string&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-使用isset代替strlen"><a href="#1-6-使用isset代替strlen" class="headerlink" title="1.6 使用isset代替strlen"></a>1.6 使用isset代替strlen</h2><p>在检验字符串长度时，我们第一想法会使用 strlen() 函数。</p>
<p>此函数执行起来相当快，因为它不做任何计算，只返回在zval结构（C的内置数据结构，用于存储PHP变量）中存储的已知字符串长度。</p>
<p>但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化、哈希查找，会跟随被调用的函数一起执行。</p>
<p>在某些情况下，你可以使用 isset() 技巧加速执行你的代码。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$foo</span>) &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Foo is too short&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用isset()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$foo</span>&#123;<span class="number">5</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Foo is too short&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-7-用split分割字符串"><a href="#1-7-用split分割字符串" class="headerlink" title="1.7 用split分割字符串"></a>1.7 用split分割字符串</h2><p>在分割字符串时，split()要比explode()快。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">split</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">0.001813</span> - <span class="number">0.002271</span> <span class="title function_ invoke__">seconds</span> (avg <span class="number">0.002042</span> seconds)</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">explode</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">0.001678</span> - <span class="number">0.003626</span> <span class="title function_ invoke__">seconds</span> (avg <span class="number">0.002652</span> seconds)</span><br></pre></td></tr></table></figure>

<h2 id="1-8-echo效率高于print"><a href="#1-8-echo效率高于print" class="headerlink" title="1.8 echo效率高于print"></a>1.8 echo效率高于print</h2><p>因为echo没有返回值，print返回一个整型。</p>
<p>注意：echo输出大字符串的时候，如果没有调整就会严重影响性能。</p>
<p>打开Apache的mod_deflate进行压缩，或者打开ob_start将内容放进缓冲区，可以改善性能问题。</p>
<h1 id="2-语句"><a href="#2-语句" class="headerlink" title="2 语句"></a>2 语句</h1><h2 id="2-1-最好不用"><a href="#2-1-最好不用" class="headerlink" title="2.1 最好不用@"></a>2.1 最好不用@</h2><p>用@掩盖错误会降低脚本运行速度，并且在后台有很多额外操作。</p>
<p>用@比起不用，效率差距 3 倍。特别不要在循环中使用@。</p>
<p>在 5 次循环的测试中，即使是先用error_reporting(0)关掉错误，循环完成后再打开，都比用@快。</p>
<h2 id="2-2-避免使用魔术方法"><a href="#2-2-避免使用魔术方法" class="headerlink" title="2.2 避免使用魔术方法"></a>2.2 避免使用魔术方法</h2><p>对于__开头的函数就命名为魔术函数，它们都在特定的条件下触发。</p>
<p>这些魔术函数包括：__construct()、__get()、__call()、__autoload()等等。</p>
<p>以__autoload() 为例，如果不能将类名与实际的磁盘文件对应起来，将不得不做大量的文件存在判断。</p>
<p>而判断文件存在需要磁盘I&#x2F;O操作，众所周知，磁盘I&#x2F;O操作的效率很低，因此这才是使得autoload机制效率降低的原因。</p>
<p>因此，在系统设计时，需要定义一套清晰的、将类名与实际磁盘文件映射的机制。</p>
<p>这个规则越简单越明确，__autoload()机制的效率就越高。</p>
<p>autoload机制并不是天然的效率低下，只有滥用autoload、设计不好的自动装载函数，才会导致其效率的降低.</p>
<p>所以说，尽量避免使用__autoload等魔术方法，有待商榷。</p>
<h2 id="2-3-别在循环里用函数"><a href="#2-3-别在循环里用函数" class="headerlink" title="2.3 别在循环里用函数"></a>2.3 别在循环里用函数</h2><p>例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$x</span>=<span class="number">0</span>; <span class="variable">$x</span> &lt; <span class="title function_ invoke__">count</span>(<span class="variable">$array</span>); <span class="variable">$x</span>++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法在每次循环的时候都会调用 count() 函数，效率大大降低，建议这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$x</span>=<span class="number">0</span>; <span class="variable">$x</span> &lt; <span class="variable">$len</span>; <span class="variable">$x</span>++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>让函数在循环外面一次获得循环次数。</p>
<h2 id="2-4-使用三元运算符"><a href="#2-4-使用三元运算符" class="headerlink" title="2.4 使用三元运算符"></a>2.4 使用三元运算符</h2><p>在简单的判断语句中，三元运算符?:更简洁高效。</p>
<h2 id="2-5-使用选择分支语句"><a href="#2-5-使用选择分支语句" class="headerlink" title="2.5 使用选择分支语句"></a>2.5 使用选择分支语句</h2><p>switch、case好于使用多个if、else if语句，并且代码更加容易阅读和维护。</p>
<h2 id="2-6-屏蔽敏感信息"><a href="#2-6-屏蔽敏感信息" class="headerlink" title="2.6 屏蔽敏感信息"></a>2.6 屏蔽敏感信息</h2><p>使用 error_reporting() 函数来预防潜在的敏感信息显示给用户。</p>
<p>理想的错误报告应该被完全禁用在php.ini文件里。</p>
<p>如果用的是共享虚拟主机，php.ini不能修改，最好添加 error_reporting() 函数。</p>
<p>放在每个脚本文件的第一行，或者用require_once()来加载，能有效的保护敏感的SQL查询和路径，在出错时不被显示。</p>
<h2 id="2-7-不实用段标签"><a href="#2-7-不实用段标签" class="headerlink" title="2.7 不实用段标签"></a>2.7 不实用段标签</h2><p>不要使用开始标志的缩写形式，你正在使用这样的符号吗，应该用完整的&lt;?php 开始标签。</p>
<p>当然，如果是输出变量，用&#x3D; $value ?&gt;这种方式是鼓励的，可以是代码更加简洁。</p>
<h2 id="2-8-纯PHP代码不加结束标记"><a href="#2-8-纯PHP代码不加结束标记" class="headerlink" title="2.8 纯PHP代码不加结束标记"></a>2.8 纯PHP代码不加结束标记</h2><p>如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记?&gt;。</p>
<p>这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。</p>
<h2 id="2-9-永远不要使用register-globals和magic-quotes"><a href="#2-9-永远不要使用register-globals和magic-quotes" class="headerlink" title="2.9 永远不要使用register_globals和magic quotes"></a>2.9 永远不要使用register_globals和magic quotes</h2><p>这是两个很古老的功能，在当时（十年前）也许是一个好方法，但现在看来并非如此。</p>
<p>老版本的PHP在安装时会默认打开这两个功能，这会引起安全漏洞、编程错误及其他的问题。</p>
<p>如只有用户输入了数据时才会创建变量等。</p>
<p>如果你过去的程序有使用这两项功能，那就尽快将其剔除吧。</p>
<h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1-尽量使用PHP内部函数"><a href="#3-1-尽量使用PHP内部函数" class="headerlink" title="3.1 尽量使用PHP内部函数"></a>3.1 尽量使用PHP内部函数</h2><p>内置函数使用C语言实现，并且经过PHP官方优化，效率更高。</p>
<h2 id="3-2-使用绝对路径"><a href="#3-2-使用绝对路径" class="headerlink" title="3.2 使用绝对路径"></a>3.2 使用绝对路径</h2><p>在include和require中尽量使用绝对路径。</p>
<p>如果包含相对路径，PHP会在include_path里面遍历查找文件。</p>
<p>用绝对路径就会避免此类问题，解析路径所需的时间会更少。</p>
<h2 id="3-3-包含文件"><a href="#3-3-包含文件" class="headerlink" title="3.3 包含文件"></a>3.3 包含文件</h2><p>尽量不要用require_once和include_once包含文件，它们多一个判断文件是否被引用的过程，能不用尽量不用。</p>
<p>而使用require、include方法代替。</p>
<p>鸟哥在其博客中就多次声明，尽量不要用require_once和include_once。</p>
<h2 id="3-4-函数快于类方法"><a href="#3-4-函数快于类方法" class="headerlink" title="3.4 函数快于类方法"></a>3.4 函数快于类方法</h2><p>调用只有一个参数、并且函数体为空的函数，花费的时间等于7-8次$localvar++运算。</p>
<p>而同一功能的类方法大约为15次$localvar++运算。</p>
<h2 id="3-5-用子类方法"><a href="#3-5-用子类方法" class="headerlink" title="3.5 用子类方法"></a>3.5 用子类方法</h2><p>基类里面只放能重用的方法，其他功能尽量放在子类中实现，子类里方法的性能优于在基类中。</p>
<h2 id="3-6-类的性能和其方法数量没有关系"><a href="#3-6-类的性能和其方法数量没有关系" class="headerlink" title="3.6 类的性能和其方法数量没有关系"></a>3.6 类的性能和其方法数量没有关系</h2><p>新添加10个或多个方法到测试的类后，性能没什么差异。</p>
<h2 id="3-7-读取文件内容"><a href="#3-7-读取文件内容" class="headerlink" title="3.7 读取文件内容"></a>3.7 读取文件内容</h2><p>在可以用file_get_contents()替代file()、fopen()、feof()、fgets()等系列方法的情况下，尽量用file_get_contents()。</p>
<p>因为他的效率高得多！</p>
<h2 id="3-8-引用传递参数"><a href="#3-8-引用传递参数" class="headerlink" title="3.8  引用传递参数"></a>3.8  引用传递参数</h2><p>通过参数地址引用的方式，实现函数多个返回值，这比按值传递效率高。</p>
<p>方法是在参数变量前加个 &amp;。</p>
<h2 id="3-9-方法不要细分得过多"><a href="#3-9-方法不要细分得过多" class="headerlink" title="3.9 方法不要细分得过多"></a>3.9 方法不要细分得过多</h2><p>仔细想想你真正打算重用的是哪些代码？</p>
<h2 id="3-10-尽量静态化"><a href="#3-10-尽量静态化" class="headerlink" title="3.10 尽量静态化"></a>3.10 尽量静态化</h2><p>如果一个方法能被静态，那就声明它为静态的，速度可提高1&#x2F;4，甚至我测试的时候，这个提高了近三倍。</p>
<p>当然了，这个测试方法需要在十万级以上次执行，效果才明显。</p>
<p>其实，静态方法和非静态方法的效率主要区别在内存。</p>
<p>静态方法在程序开始时生成内存，实例方法（非静态方法）在程序运行中生成内存。</p>
<p>所以，静态方法可以直接调用，实例方法要先成生实例再调用，静态速度很快，但是多了会占内存。</p>
<p>任何语言都是对内存和磁盘的操作，至于是否面向对象，只是软件层的问题，底层都是一样的，只是实现方法不同。</p>
<p>静态内存是连续的，因为是在程序开始时就生成了，而实例方法申请的是离散的空间，所以当然没有静态方法快。</p>
<p>静态方法始终调用同一块内存，其缺点就是不能自动进行销毁，而实例化可以销毁。</p>
<h2 id="3-11-用C扩展方式实现"><a href="#3-11-用C扩展方式实现" class="headerlink" title="3.11 用C扩展方式实现"></a>3.11 用C扩展方式实现</h2><p>如果在代码中存在大量耗时的函数，可以考虑用C扩展的方式实现它们。</p>
<h1 id="4-变量"><a href="#4-变量" class="headerlink" title="4 变量"></a>4 变量</h1><h2 id="4-1-及时销毁变量"><a href="#4-1-及时销毁变量" class="headerlink" title="4.1 及时销毁变量"></a>4.1 及时销毁变量</h2><p>数组、对象和GLOBAL变量在 PHP 中特别占内存的，这个由于 PHP 的底层的zend引擎引起的。</p>
<p>一般来说，PHP数组的内存利用率只有 1&#x2F;10。</p>
<p>也就是说，一个在C语言里面100M 内存的数组，在PHP里面就要1G。</p>
<p>特别是，在PHP作为后台服务器的系统中，经常会出现内存耗费太大的问题。</p>
<h2 id="4-2-使用-SERVER变量"><a href="#4-2-使用-SERVER变量" class="headerlink" title="4.2 使用$_SERVER变量"></a>4.2 使用$_SERVER变量</h2><p>如果你需要得到脚本执行的时间，$_SERVER[‘REQUSET_TIME’]优于time()。</p>
<p>一个是现成就可以直接用，一个还需要函数得出的结果。</p>
<h2 id="4-3-方法里建立局部变量"><a href="#4-3-方法里建立局部变量" class="headerlink" title="4.3 方法里建立局部变量"></a>4.3 方法里建立局部变量</h2><p>在类的方法里建立局部变量速度最快，几乎和在方法里调用局部变量一样快。</p>
<h2 id="4-4-局部变量比全局变量快"><a href="#4-4-局部变量比全局变量快" class="headerlink" title="4.4 局部变量比全局变量快"></a>4.4 局部变量比全局变量快</h2><p>由于局部变量是存在栈中的。</p>
<p>当一个函数占用的栈空间不是很大的时候，这部分内存很有可能全部命中cache，CPU访问的效率是很高的。</p>
<p>相反，如果一个函数同时使用全局变量和局部变量，当这两段地址相差较大时，cpu cache需要来回切换，效率会下降。</p>
<h2 id="4-5-局部变量而不是对象属性"><a href="#4-5-局部变量而不是对象属性" class="headerlink" title="4.5 局部变量而不是对象属性"></a>4.5 局部变量而不是对象属性</h2><p>建立一个对象属性（类里面的变量，例如：$this-&gt;prop++）比局部变量要慢3倍。</p>
<h2 id="4-6-提前声明局部变量"><a href="#4-6-提前声明局部变量" class="headerlink" title="4.6 提前声明局部变量"></a>4.6 提前声明局部变量</h2><p>建立一个未声明的局部变量，要比建立一个已经定义过的局部变量慢9-10倍。</p>
<h2 id="4-7-谨慎声明全局变量"><a href="#4-7-谨慎声明全局变量" class="headerlink" title="4.7 谨慎声明全局变量"></a>4.7 谨慎声明全局变量</h2><p>声明一个未被任何一个函数使用过的全局变量，也会使性能降低。</p>
<p>这和声明相同数量的局部变量一样，PHP可能去检查这个全局变量是否存在。</p>
<h2 id="4-8-使用-i递增"><a href="#4-8-使用-i递增" class="headerlink" title="4.8 使用++$i递增"></a>4.8 使用++$i递增</h2><p>当执行变量$i的递增或递减时，$i++会比++$i慢一些。</p>
<p>这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或Java代码，并指望它们能立即变快，没用的。</p>
<p>++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。</p>
<p>后置递增实际上会产生一个临时变量，这个临时变量随后被递增。</p>
<p>而前置递增直接在原值上递增。</p>
<p>这是最优化处理的一种，正如Zend的PHP优化器所作的那样。</p>
<p>牢记，这个优化处理不失为一个好主意，因为不是所有的指令优化器都会做同样的优化处理。</p>
<h2 id="4-9-不要随便复制变量"><a href="#4-9-不要随便复制变量" class="headerlink" title="4.9 不要随便复制变量"></a>4.9 不要随便复制变量</h2><p>有时候为了使 PHP 代码更加整洁，一些 PHP 新手（包括我）会把预定义好的变量，复制到一个名字更简短的变量中。</p>
<p>其实这样做的结果是增加了一倍的内存消耗，只会使程序更加慢。</p>
<p>试想一下，在下面的例子中，如果用户恶意插入 512KB 字节的文字，就会导致 1MB 的内存被消耗！</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的实践</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$description</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;description&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$description</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的实践</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;description&#x27;</span>];</span><br></pre></td></tr></table></figure>



<h2 id="4-10-循环内部不要声明变量"><a href="#4-10-循环内部不要声明变量" class="headerlink" title="4.10 循环内部不要声明变量"></a>4.10 循环内部不要声明变量</h2><p>尤其是大变量，这好像不只是PHP里面要注意的问题吧？</p>
<h2 id="4-11-一定要对变量进行初始化"><a href="#4-11-一定要对变量进行初始化" class="headerlink" title="4.11 一定要对变量进行初始化"></a>4.11 一定要对变量进行初始化</h2><p>这里的“初始化”指的是“声明”。</p>
<p>当需要没有初始化的变量，PHP解释器会自动创建一个变量，但依靠这个特性来编程并不是一个好主意。</p>
<p>这会造成程序的粗糙，或者使代码变得另人迷惑。</p>
<p>因为你需要探寻这个变量是从哪里开始被创建的。</p>
<p>另外，对一个没有初始化的变量进行递增操作要比初始化过的来得慢。</p>
<p>所以对变量进行初始化会是个不错的主意。</p>
<h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h1><h2 id="5-1-用字符串而不是数组作为参数"><a href="#5-1-用字符串而不是数组作为参数" class="headerlink" title="5.1 用字符串而不是数组作为参数"></a>5.1 用字符串而不是数组作为参数</h2><p>如果一个函数既能接受数组，又能接受简单字符做为参数，那么尽量用字符作为参数。</p>
<p>例如，字符替换函数，参数列表并不是太长，就可以考虑额外写一段替换代码。</p>
<p>使得每次传递参数都是一个字符，而不是接受数组做为查找和替换参数。</p>
<h2 id="5-2-数组元素加引号"><a href="#5-2-数组元素加引号" class="headerlink" title="5.2 数组元素加引号"></a>5.2 数组元素加引号</h2><p>$row[‘id’]比$row[id]速度快7倍。</p>
<p>如果不带引号，例如$a[name]，那么PHP会首先检查有没有define定义的name常量。</p>
<p>如果有，就用这个常量值作为数组键值。如果没有，再查找键值为字符串’name’的数组元素。</p>
<p>多了一个查找判断的过程，所以建议养成数组键名加引号的习惯。</p>
<p>正如上面字符串部分所述，用’又比用”速度更快。</p>
<h2 id="5-3-多维数组操作"><a href="#5-3-多维数组操作" class="headerlink" title="5.3 多维数组操作"></a>5.3 多维数组操作</h2><p>多维数组尽量不要循环嵌套赋值。</p>
<h2 id="5-4-循环用foreach"><a href="#5-4-循环用foreach" class="headerlink" title="5.4 循环用foreach"></a>5.4 循环用foreach</h2><p>尽量用foreach代替while和for循环，效率更高。</p>
<h1 id="6-架构"><a href="#6-架构" class="headerlink" title="6 架构"></a>6 架构</h1><h2 id="6-1-压缩输出"><a href="#6-1-压缩输出" class="headerlink" title="6.1 压缩输出"></a>6.1 压缩输出</h2><p>在php.ini中开启gzip压缩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zlib.output_compression = On</span><br><span class="line"></span><br><span class="line">zlib.output_compression_level = (level)</span><br></pre></td></tr></table></figure>


<p>level可能是1-9之间的数字，你可以设置不同的数字。</p>
<p>几乎所有的浏览器都支持Gzip的压缩方式，gzip可以降低80%的输出.</p>
<p>付出的代价是，大概增加了10%的cpu计算量。</p>
<p>但是还是会赚到了，因为带宽减少了，页面加载会变得很快。</p>
<p>如果你使用apache，也可以激活mod_gzip模块。</p>
<h2 id="6-2-静态化页面"><a href="#6-2-静态化页面" class="headerlink" title="6.2 静态化页面"></a>6.2 静态化页面</h2><p>Apache&#x2F;Nginx解析一个PHP脚本的时间，要比解析一个静态HTML页面慢2至10倍。</p>
<p>所以尽量使页面静态化，或使用静态HTML页面。</p>
<h2 id="6-3-将PHP升级到最新版"><a href="#6-3-将PHP升级到最新版" class="headerlink" title="6.3 将PHP升级到最新版"></a>6.3 将PHP升级到最新版</h2><p>提高性能的最简单的方式是不断升级、更新PHP版本。</p>
<h2 id="6-4-利用PHP的扩展"><a href="#6-4-利用PHP的扩展" class="headerlink" title="6.4 利用PHP的扩展"></a>6.4 利用PHP的扩展</h2><p>一直以来，大家都在抱怨PHP内容太过繁杂。</p>
<p>最近几年来，开发人员作出了相应的努力，移除了项目中的一些冗余特征。</p>
<p>即便如此，可用库以及其它扩展的数量还是很可观。</p>
<p>甚至一些开发人员开始考虑实施自己的扩展方案。</p>
<h2 id="6-5-PHP缓存"><a href="#6-5-PHP缓存" class="headerlink" title="6.5 PHP缓存"></a>6.5 PHP缓存</h2><p>一般情况下，PHP脚本被PHP引擎编译后执行，会被转换成机器语言，也称为操作码。</p>
<p>如果PHP脚本反复编译得到相同的结果，为什么不完全跳过编译过程呢？</p>
<p>PHP加速器缓存了编译后的机器码，允许代码根据要求立即执行，而不经过繁琐的编译过程。</p>
<p>对PHP开发人员而言，目前提供了两种可用的缓存方案。</p>
<p>一种是APC（Alternative PHP Cache，可选PHP缓存），它是一个可以通过PEAR安装的开源加速器。</p>
<p>另一种流行的方案是OPCode，也就是操作码缓存技术。</p>
<h2 id="6-6-使用NoSQL缓存"><a href="#6-6-使用NoSQL缓存" class="headerlink" title="6.6 使用NoSQL缓存"></a>6.6 使用NoSQL缓存</h2><p>Memchached或者Redis都可以。</p>
<p>这些是高性能的分布式内存对象缓存系统，能提高动态网络应用程序性能，减轻数据库的负担。</p>
<p>这对运算码 （OPcode）的缓存也很有用，使得脚本不必为每个请求重新编译。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>48条高效率的PHP优化写法</p><p><a href="https://kkai.blog/48条高效率的PHP优化写法/">https://kkai.blog/48条高效率的PHP优化写法/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>kkai</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-05-31</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-04-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://www.buymeacoffee.com/kkai" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E3%80%81%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git多账号、密钥管理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89swiper%20dots/"><span class="level-item">小程序中自定义swiper的dots</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="kkai"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">kkai</p><p class="is-size-6 is-block">Quantum Sensing &amp; Computing</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/sneiiler" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/LaTeX/"><span class="level-start"><span class="level-item">LaTeX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">小程序</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"><span class="level-start"><span class="level-item">计算机</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">-网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/shell/"><span class="level-start"><span class="level-item">shell</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-01T09:05:41.000Z">2022-05-01</time></p><p class="title"><a href="/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83/">关于数字经济相关的思考</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-08-15T04:59:51.000Z">2018-08-15</time></p><p class="title"><a href="/%E4%BF%AE%E6%94%B9Anaconda%E4%B8%AD%E7%9A%84Jupyter-Notebook%E9%BB%98%E8%AE%A4%E5%B7%A5%E4%BD%9C%E8%B7%AF%E5%BE%84/">修改Anaconda中的Jupyter Notebook默认工作路径-update</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-08-12T09:37:32.000Z">2018-08-12</time></p><p class="title"><a href="/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/">最近一段时间的总结（2018年上半年）</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-07-01T05:21:58.000Z">2018-07-01</time></p><p class="title"><a href="/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">hexo常用命令</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-06-02T14:35:02.000Z">2018-06-02</time></p><p class="title"><a href="/tar%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/">tar命令的使用</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A4%BE%E4%BC%9A%E8%AE%A4%E7%9F%A5/"><span class="tag">社会认知</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/ban_logo.png" alt="大风" height="28"></a><p class="is-size-7"><span>&copy; 2022 kkai</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>